// 2018#5
// Description:

// 一个整数，输出其长度，输出 1 到该数字，输出这串数字其中有多少个 “1”

// Code:

#include<stdio.h>
#include<stdlib.h>

char *my_itoa(int num, char *str)
{
        if(str == NULL)
        {
            return NULL;
        }
        sprintf(str, "%d", num);
        return str;
}

int calc_len(int num)
{
    int l = 0;
    while (num)
    {
        num = num / 10;
        l++;
    }
    return l;
}

// 遍历数字，数字转化为字符串，实现统计 1 的数量
// 速度很慢，做对照验证用
int traversal_count_ones(int num)
{
    char str[16] = {0};
    int ones = 0;
    for(int i = 0; i <= num; i++)
    {
        my_itoa(i, str);
        for(int j = 0; j < 16; j++)
        {
            if(str[j] == '1')
                ones++;
        }
    }
    
    return ones;
}

// 计算数字 1 出现次数
// 思路是将分成两部分计算 1 的数量
// 以数字 211 为例
// 从低位到高位
// 
// 先从高位重复次数，计算该位是 1 的情况
// 个位为 1 的情况，如 1，11,21，……，201，百位和十位 211 / 10 = 21，共 21 次。
// 十位为 1 的情况同理，10,110，有 211 / 100 = 2 次，
// 百位为 1 的情况同理，有 211 / 1000 = 0 次
// 
// 再计算上一步的余数中有多少个 1
// 个位为 1，211 / 10 = 21……1,
// 余数最高位为 1 有 211 一种情况个位是 1
// 十位为 1，211 / 10 = 200……11
// 余数最高位为 1 有 210,211，两种情况十位是 1
// 百位为 2，211 / 1000 = 0……211，
// 余数最高位大于 1，有 100 到 199 百位全是 1
// 需要注意，以数字 211 为例，在十位为 1 和百位为 1 两种情况都有出现，
// 但两次分别只记上了个位和十位的 1，所以 211 出现了两次，每次只记录上一个 1，总量是两个 1
// 
// 这个非常快，复杂度 O(len) 级别
int calc_count_ones(int num)
{
    int carry = 1;
    int ones = 0;
    while(num / carry)
    {
        // 高一位重复了多少次，即当位是 1 的情况出现多少次
        ones += num / (10 * carry) * carry;

        // 当位数字
        int n = num % (10 * carry) / carry;
        
        // 当位如果大于 1
        if(n > 1)
        {
            // 当位大于 1 时，该位为 1 的数有多少个
            ones += 1 * carry;
        }
        else if(n == 1)
        {
            // 当位是 1 时，该位为 1 的数有多少个
            ones += 1;
            ones += num % carry;
        }
        
        carry *= 10;
    }
    return ones;
}

int main()
{
    int num = 0;
    while(1)
    {
        scanf("%d", &num);
        printf("the length is:\t%d\n", calc_len(num));
        for(int i = 1; i <= num; i++)
        {
            printf("%d ", i);
        }
        printf("\ncount of 1 is:\t%d\n", traversal_count_ones(num));
        printf("count of 1 is:\t%d\n", calc_count_ones(num));
    }
}


// Input/Output:

// 211
// the length is:  3
// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 
// count of 1 is:  144
// count of 1 is:  144